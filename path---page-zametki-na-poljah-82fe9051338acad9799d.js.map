{"version":3,"sources":["webpack:///path---page-zametki-na-poljah-82fe9051338acad9799d.js","webpack:///./.cache/json/page-zametki-na-poljah.json"],"names":["webpackJsonp","367","module","exports","data","markdownRemark","html","frontmatter","date","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,yyEAA8wEC,aAAyDC,KAAA,sBAAAC,KAAA,0BAAAC,MAAA,4BAAiGC","file":"path---page-zametki-na-poljah-82fe9051338acad9799d.js","sourcesContent":["webpackJsonp([276384461243045],{\n\n/***/ 367:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Ответы на часто возникающие вопросы при изучении C++, мои типичные ошибки, ссылки</p>\\n<p>[xcut]</p>\\n<p>_ Хороший стиль:\\nul</p>\\n<ul>\\n<li>Имена переменных, аргументов начинаются с прописной буквы, если состоит из нескольких слов, то чередуется, например\\n_ product и productPrice\\n/ul</li>\\n</ul>\\n<p>_ Мои типичные ошибки:\\nul</p>\\n<ul>\\n<li>Использование в конструкторе и в функциях в качестве аргументов скрытые элементы данных, объявленные в заголовочном файле(интерфейсе)</li>\\n<li>Указание в конструкторе при инициализации функций тип аргумента</li>\\n<li>Указание возвращаемого типа в конструкторе при инициализации функции</li>\\n<li>Отсутствие возвращаемого типа перед функцией в интерфейсе\\n_ компилятор должен знать какой типа возвращает функция до её реализации</li>\\n<li>Отсутствует \\\";\\\"(точка с запятой) в конце определения класса в интерфейсе\\n/ul</li>\\n</ul>\\n<p>_ Незабудька:\\nul</p>\\n<ul>\\n<li>Во вложенных оператораъ if..else сначала проверять наиболее распространённые случаи, это способствует более быстрой отработке внутренних if..else стр.210</li>\\n<li>Число повторений - число интераций цикла</li>\\n<li>Переменные для хранения сумм перед их использованием инициализируются нулём</li>\\n<li>В .h файлах содержатся прототипы функций\\n_ Организация исходников C++ (<a href=\\\"https://toster.ru/q/12136\\\">https://toster.ru/q/12136</a>)\\n_ <a href=\\\"\\\">show показать/спрятать</a>Для себя сделал такую структуру (часто использую в проектах если больше 3 тысяч строк)</li>\\n<li>Всё лежит в одном месте</li>\\n<li>C/CPP файлы содержат код, а в заголовке содержат include «header.h»</li>\\n<li>все H файлы содержат прототипы функций, константы и структуры, которые относятся в C/CPP файлу.</li>\\n<li>в файле header.h прописываются все заголовочные файлы (сначала системные, потом свои)</li>\\n</ul>\\n<p>Таким образом очень легко править всё что связано с одним файлом кода (H и CPP файлы имеют одно имя, ток расширение разное). При добавлении нового модуля, нет необходимости прописывать его заголовочный файл в каждом исходнике где он используется, достаточно прописать только в header.h</p>\\n<p>И к тому же такой подход позволяет легко обходить ситуации с взаимный include (первый на второго, а второй на первый)<a href=\\\"\\\">/pre</a></p>\\n<ul>\\n<li>Class.h - интерфейс; Class.cpp - реализация; main.cpp - код клиента\\n/ul</li>\\n</ul>\",\"frontmatter\":{\"date\":\"2015-10-25 08:52:56\",\"path\":\"/page/zametki-na-poljah\",\"title\":\"Заметки 'на полях' C++\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---page-zametki-na-poljah-82fe9051338acad9799d.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Ответы на часто возникающие вопросы при изучении C++, мои типичные ошибки, ссылки</p>\\n<p>[xcut]</p>\\n<p>_ Хороший стиль:\\nul</p>\\n<ul>\\n<li>Имена переменных, аргументов начинаются с прописной буквы, если состоит из нескольких слов, то чередуется, например\\n_ product и productPrice\\n/ul</li>\\n</ul>\\n<p>_ Мои типичные ошибки:\\nul</p>\\n<ul>\\n<li>Использование в конструкторе и в функциях в качестве аргументов скрытые элементы данных, объявленные в заголовочном файле(интерфейсе)</li>\\n<li>Указание в конструкторе при инициализации функций тип аргумента</li>\\n<li>Указание возвращаемого типа в конструкторе при инициализации функции</li>\\n<li>Отсутствие возвращаемого типа перед функцией в интерфейсе\\n_ компилятор должен знать какой типа возвращает функция до её реализации</li>\\n<li>Отсутствует \\\";\\\"(точка с запятой) в конце определения класса в интерфейсе\\n/ul</li>\\n</ul>\\n<p>_ Незабудька:\\nul</p>\\n<ul>\\n<li>Во вложенных оператораъ if..else сначала проверять наиболее распространённые случаи, это способствует более быстрой отработке внутренних if..else стр.210</li>\\n<li>Число повторений - число интераций цикла</li>\\n<li>Переменные для хранения сумм перед их использованием инициализируются нулём</li>\\n<li>В .h файлах содержатся прототипы функций\\n_ Организация исходников C++ (<a href=\\\"https://toster.ru/q/12136\\\">https://toster.ru/q/12136</a>)\\n_ <a href=\\\"\\\">show показать/спрятать</a>Для себя сделал такую структуру (часто использую в проектах если больше 3 тысяч строк)</li>\\n<li>Всё лежит в одном месте</li>\\n<li>C/CPP файлы содержат код, а в заголовке содержат include «header.h»</li>\\n<li>все H файлы содержат прототипы функций, константы и структуры, которые относятся в C/CPP файлу.</li>\\n<li>в файле header.h прописываются все заголовочные файлы (сначала системные, потом свои)</li>\\n</ul>\\n<p>Таким образом очень легко править всё что связано с одним файлом кода (H и CPP файлы имеют одно имя, ток расширение разное). При добавлении нового модуля, нет необходимости прописывать его заголовочный файл в каждом исходнике где он используется, достаточно прописать только в header.h</p>\\n<p>И к тому же такой подход позволяет легко обходить ситуации с взаимный include (первый на второго, а второй на первый)<a href=\\\"\\\">/pre</a></p>\\n<ul>\\n<li>Class.h - интерфейс; Class.cpp - реализация; main.cpp - код клиента\\n/ul</li>\\n</ul>\",\"frontmatter\":{\"date\":\"2015-10-25 08:52:56\",\"path\":\"/page/zametki-na-poljah\",\"title\":\"Заметки 'на полях' C++\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/page-zametki-na-poljah.json\n// module id = 367\n// module chunks = 276384461243045"],"sourceRoot":""}