{"version":3,"sources":["webpack:///path---page-zametki-na-poljah-e8fe6cc366282311b80d.js","webpack:///./.cache/json/page-zametki-na-poljah.json"],"names":["webpackJsonp","571","module","exports","data","markdownRemark","html","frontmatter","date","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,kzEAAgxEC,aAA4DC,KAAA,aAAAC,KAAA,0BAAAC,MAAA,4BAAwFC","file":"path---page-zametki-na-poljah-e8fe6cc366282311b80d.js","sourcesContent":["webpackJsonp([276384461243045],{\n\n/***/ 571:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Ответы на часто возникающие вопросы при изучении C++, мои типичные ошибки, ссылки</p>\\n<p>[xcut]</p>\\n<p>— Хороший стиль:\\nul</p>\\n<ul>\\n<li>Имена переменных, аргументов начинаются с прописной буквы, если состоит из нескольких слов, то чередуется, например\\n— product и productPrice\\n/ul</li>\\n</ul>\\n<p>— Мои типичные ошибки:\\nul</p>\\n<ul>\\n<li>Использование в конструкторе и в функциях в качестве аргументов скрытые элементы данных, объявленные в заголовочном файле(интерфейсе)</li>\\n<li>Указание в конструкторе при инициализации функций тип аргумента</li>\\n<li>Указание возвращаемого типа в конструкторе при инициализации функции</li>\\n<li>Отсутствие возвращаемого типа перед функцией в интерфейсе\\n— компилятор должен знать какой типа возвращает функция до её реализации</li>\\n<li>Отсутствует \\\";\\\"(точка с запятой) в конце определения класса в интерфейсе\\n/ul</li>\\n</ul>\\n<p>— Незабудька:\\nul</p>\\n<ul>\\n<li>Во вложенных оператораъ if..else сначала проверять наиболее распространённые случаи, это способствует более быстрой отработке внутренних if..else стр.210</li>\\n<li>Число повторений - число интераций цикла</li>\\n<li>Переменные для хранения сумм перед их использованием инициализируются нулём</li>\\n<li>\\n<p>В .h файлах содержатся прототипы функций\\n— Организация исходников C++ (<a href=\\\"https://toster.ru/q/12136\\\">https://toster.ru/q/12136</a>)\\n— *  показать/спрятать</p>\\n<pre><code>Для себя сделал такую структуру (часто использую в проектах если больше 3 тысяч строк)\\n</code></pre>\\n</li>\\n<li>Всё лежит в одном месте</li>\\n<li>C/CPP файлы содержат код, а в заголовке содержат include «header.h»</li>\\n<li>все H файлы содержат прототипы функций, константы и структуры, которые относятся в C/CPP файлу.</li>\\n<li>в файле header.h прописываются все заголовочные файлы (сначала системные, потом свои)</li>\\n</ul>\\n<p>Таким образом очень легко править всё что связано с одним файлом кода (H и CPP файлы имеют одно имя, ток расширение разное). При добавлении нового модуля, нет необходимости прописывать его заголовочный файл в каждом исходнике где он используется, достаточно прописать только в header.h</p>\\n<p>И к тому же такой подход позволяет легко обходить ситуации с взаимный include (первый на второго, а второй на первый)</p>\\n<pre><code>* Class.h - интерфейс; Class.cpp - реализация; main.cpp - код клиента\\n/ul\\n</code></pre>\",\"frontmatter\":{\"date\":\"2015-10-25\",\"path\":\"/page/zametki-na-poljah\",\"title\":\"Заметки 'на полях' C++\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---page-zametki-na-poljah-e8fe6cc366282311b80d.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Ответы на часто возникающие вопросы при изучении C++, мои типичные ошибки, ссылки</p>\\n<p>[xcut]</p>\\n<p>— Хороший стиль:\\nul</p>\\n<ul>\\n<li>Имена переменных, аргументов начинаются с прописной буквы, если состоит из нескольких слов, то чередуется, например\\n— product и productPrice\\n/ul</li>\\n</ul>\\n<p>— Мои типичные ошибки:\\nul</p>\\n<ul>\\n<li>Использование в конструкторе и в функциях в качестве аргументов скрытые элементы данных, объявленные в заголовочном файле(интерфейсе)</li>\\n<li>Указание в конструкторе при инициализации функций тип аргумента</li>\\n<li>Указание возвращаемого типа в конструкторе при инициализации функции</li>\\n<li>Отсутствие возвращаемого типа перед функцией в интерфейсе\\n— компилятор должен знать какой типа возвращает функция до её реализации</li>\\n<li>Отсутствует \\\";\\\"(точка с запятой) в конце определения класса в интерфейсе\\n/ul</li>\\n</ul>\\n<p>— Незабудька:\\nul</p>\\n<ul>\\n<li>Во вложенных оператораъ if..else сначала проверять наиболее распространённые случаи, это способствует более быстрой отработке внутренних if..else стр.210</li>\\n<li>Число повторений - число интераций цикла</li>\\n<li>Переменные для хранения сумм перед их использованием инициализируются нулём</li>\\n<li>\\n<p>В .h файлах содержатся прототипы функций\\n— Организация исходников C++ (<a href=\\\"https://toster.ru/q/12136\\\">https://toster.ru/q/12136</a>)\\n— *  показать/спрятать</p>\\n<pre><code>Для себя сделал такую структуру (часто использую в проектах если больше 3 тысяч строк)\\n</code></pre>\\n</li>\\n<li>Всё лежит в одном месте</li>\\n<li>C/CPP файлы содержат код, а в заголовке содержат include «header.h»</li>\\n<li>все H файлы содержат прототипы функций, константы и структуры, которые относятся в C/CPP файлу.</li>\\n<li>в файле header.h прописываются все заголовочные файлы (сначала системные, потом свои)</li>\\n</ul>\\n<p>Таким образом очень легко править всё что связано с одним файлом кода (H и CPP файлы имеют одно имя, ток расширение разное). При добавлении нового модуля, нет необходимости прописывать его заголовочный файл в каждом исходнике где он используется, достаточно прописать только в header.h</p>\\n<p>И к тому же такой подход позволяет легко обходить ситуации с взаимный include (первый на второго, а второй на первый)</p>\\n<pre><code>* Class.h - интерфейс; Class.cpp - реализация; main.cpp - код клиента\\n/ul\\n</code></pre>\",\"frontmatter\":{\"date\":\"2015-10-25\",\"path\":\"/page/zametki-na-poljah\",\"title\":\"Заметки 'на полях' C++\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/page-zametki-na-poljah.json\n// module id = 571\n// module chunks = 276384461243045"],"sourceRoot":""}